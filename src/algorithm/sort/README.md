## 常用排序和搜索算法

### Catalog

- [冒泡排序](#冒泡排序)
- [选择排序](#选择排序)
- [插入排序](#插入排序)
- [归并排序](#归并排序)
- [快速排序](#快速排序)

### 冒泡排序

#### 思想

冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。

排序过程如下：
![bubble-sort](../../../assets/bubble-sort.png)

优化后排序过程：
![bubble-sort-improved](../../../assets/bubble-sort-improved.png)

#### 实现

- [简单冒泡排序](./bubble-sort.js)
- [冒泡排序优化](./bubble-sort-improved.js)

#### 时间复杂度

时间复杂度为`O(n2)`

#### 应用

-

### 选择排序

#### 思想

选择排序是一种原址比较排序算法。大致思路是找到数据结构中的最小值并将其位置放在第一位，接着找到第二小的值并将其放在第二位，以此类推。

排序过程如下：
![selection-sort](../../../assets/selection-sort.png)

#### 实现

- [选择排序](./selection-sort.js)

#### 时间复杂度

时间复杂度为`O(n2)`

#### 应用

-

### 插入排序

#### 思想

插入排序每次拍一个数组项，以此方式构建最后的排序数组。嘉定第一项已经排序好了，接着，它和第二项进行比较，第二项是应该待在原味还是插入到第一项之前呢？这样，头两项就已正确排序，接着喝第三项比较（它是该插入到第一、第二还是第三的位置呢？），以此类推。

排序过程如下：
![insertion-sort](../../../assets/insertion-sort.png)

#### 实现

- [插入排序](./insertion-sort.js)

#### 时间复杂度

时间复杂度为O(n2)，不过在小型数组时，此算法比选择排序和冒泡排序性能要好。

#### 应用

-

### 归并排序

#### 思想

归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，知道每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。

排序过程如下：
![merge-sort](../../../assets/merge-sort.png)

#### 实现

- [归并排序](./merge-sort.js)

#### 时间复杂度

时间复杂度为O(nlogn)

#### 应用

-

### 快速排序
#### 思想
#### 实现
#### 时间复杂度
#### 应用
