## 常用排序和搜索算法

### Catalog

- [冒泡排序](#冒泡排序)
- [选择排序](#选择排序)
- [插入排序](#插入排序)
- [归并排序](#归并排序)
- [快速排序](#快速排序)
- [堆排序](#堆排序)

### 冒泡排序

#### 思想

冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换它们。

排序过程如下：
![bubble-sort](../../../assets/bubble-sort.png)

优化后排序过程：
![bubble-sort-improved](../../../assets/bubble-sort-improved.png)

#### 实现

- [简单冒泡排序](./bubble-sort.js)
- [冒泡排序优化](./bubble-sort-improved.js)

#### 时间复杂度

- 最佳情况：当输入的数组为已排好序 T(n) = O(n)
- 最坏情况：当输入的数组为反序时 T(n) = O(n2)
- 平均情况： T(n) = O(n2)

时间复杂度为`O(n2)`

#### 应用

-

### 选择排序

#### 思想

选择排序是一种原址比较排序算法。大致思路是找到数据结构中的最小值并将其位置放在第一位，接着找到第二小的值并将其放在第二位，以此类推。

排序过程如下：
![selection-sort](../../../assets/selection-sort.png)

#### 实现

- [选择排序](./selection-sort.js)

#### 时间复杂度

- 最佳情况： T(n) = O(n2)
- 最坏情况： T(n) = O(n2)
- 平均情况： T(n) = O(n2)

平均情况时间复杂度为`O(n2)`

#### 应用

-

### 插入排序

#### 思想

插入排序每次拍一个数组项，以此方式构建最后的排序数组。嘉定第一项已经排序好了，接着，它和第二项进行比较，第二项是应该待在原味还是插入到第一项之前呢？这样，头两项就已正确排序，接着喝第三项比较（它是该插入到第一、第二还是第三的位置呢？），以此类推。

排序过程如下：
![insertion-sort](../../../assets/insertion-sort.png)

#### 实现

- [插入排序](./insertion-sort.js)

#### 时间复杂度

- 最佳情况：输入数组按升序排序  T(n) = O(n)
- 最坏情况：输入数组按降序排序 T(n) = O(n2)
- 平均情况： T(n) = O(n2)

平均情况时间复杂度为O(n2)，不过在小型数组时，此算法比选择排序和冒泡排序性能要好。

#### 应用

- chrome下的v8在数据量小于10时使用插入排序，大于10时使用快速排序。

### 归并排序

#### 思想

归并排序是一种分治算法。其思想是将原始数组切分成较小的数组，知道每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。

排序过程如下：
![merge-sort](../../../assets/merge-sort.png)

#### 实现

- [归并排序](./merge-sort.js)

#### 时间复杂度

- 最佳情况： T(n) = O(n)
- 最坏情况： T(n) = O(nlogn)
- 平均情况： T(n) = O(nlogn)

平均情况时间复杂度为O(nlogn)

#### 应用

- Firefox使用归并排序实现内部的sort方法

### 快速排序

#### 思想

和归并排序一样，快排也使用分治的方法，将原始数组分为较小的数组。

- 首先，从数组中选择一项作为主元。
  - 最简单的是选择数组第一项。但研究表明，对于几乎已排序的数组，这会导致时间复杂度最坏到O(n2)。
  - 另一种是选择数组的中间项。也是本库的实现方式。
  - 还可以随机选择一个数组项。
- 新建两个新数组，将原数组遍历，小于主元的值放入`left`数组，大于主元的值放入`right`数组。
- 将`left`和`right`递归进行此操作，直到数组长度为1即已排序好为止。
- 将`left``主元``right`归并起来即为已排好序的数组。

#### 实现

- [快速排序](./quick-sort.js)

#### 时间复杂度

- 最佳情况： T(n) = O(nlogn)
- 最坏情况： T(n) = O(n2)
- 平均情况： T(n) = O(nlogn)

平均情况时间复杂度为O(nlogn)，且它的性能比其他复杂度为O(nlogn)的排序算法要好。

#### 应用

- chrome下的v8在数据量小于10时使用插入排序，大于10时使用快速排序。


### 堆排序

#### 思想

堆排序是一种很高效的算法，因为它把数组当做二叉树来排序。

堆具备的特性：
  - 索引0是树的根节点
  - 除根节点外，任意节点N的父节点是N/2
  - 节点L的左子节点是2*L
  - 节点L的右子节点时2*L+1

也基于大根堆的特性：
  - 父节点的值始终比子节点值大
  - （小根堆则相反，父节点的值小于子节点的值）

对数组`[3，5，1，6，4，7，2]`构建成大根堆的过程如下：
![heap-sort-maxHeap](../../../assets/heap-sort-maxHeap.png)

然后进行堆排序
![heap-sort](../../../assets/heap-sort.png)

#### 实现

- [堆排序](./heap-sort.js)

#### 时间复杂度

- 最佳情况： T(n) = O(nlogn)
- 最坏情况： T(n) = O(nlogn)
- 平均情况： T(n) = O(nlogn)
#### 应用

-

### 计数排序
#### 思想
#### 实现
#### 时间复杂度
#### 应用


### 桶排序
#### 思想
#### 实现
#### 时间复杂度
#### 应用
